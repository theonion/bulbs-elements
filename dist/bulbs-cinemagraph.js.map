{"version":3,"sources":["webpack:///bulbs-cinemagraph.js","webpack:///./elements/bulbs-cinemagraph/bulbs-cinemagraph.js","webpack:///./~/iphone-inline-video/dist/iphone-inline-video.common-js.js","webpack:///./~/poor-mans-symbol/dist/poor-mans-symbol.common-js.js","webpack:///./~/intervalometer/dist/intervalometer.common-js.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","default","_defaults","defaults","keys","getOwnPropertyNames","i","length","value","getOwnPropertyDescriptor","configurable","undefined","defineProperty","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","setPrototypeOf","BulbsHTMLVideoElement","_register","_util","_iphoneInlineVideo","iphoneInlineVideo","HTMLVideoElement","BulbsCinemagraph","_BulbsHTMLVideoElemen","this","apply","arguments","createdCallback","get","parseFloat","getAttribute","attachedCallback","_this2","hasAttribute","console","warn","setAttribute","addEventListener","play","pause","InViewMonitor","add","detachedCallback","remove","extends","registerElement","221","_interopDefault","ex","preventEvent","element","eventName","toggleProperty","preventWithProperty","handler","e","Boolean","stopImmediatePropagation","proxyProperty","object","propertyName","sourceObject","copyFirst","set","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","setTime","time","rememberOnly","lastTimeupdateEvent","Date","now","ಠevent","currentTime","lastRequests","requestIndex","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","loop","networkState","NETWORK_IDLE","buffered","load","ended","ಠ","webkitDisplayingFullscreen","ಠplay","paused","updater","start","HAVE_ENOUGH_DATA","forceEvents","stop","ಠpause","addPlayer","intervalometer","frameIntervalometer","bind","muted","wasEmpty","indexOf","overloadAPI","enableInlineVideo","onlyWhitelisted","isWhitelisted","classList","autoplay","test","navigator","platform","Symbol","document","head","style","userAgent","matchMedia","matches","222","index","description","Math","random","223","cb","request","cancel","requestParameter","requestId","previousLoopTime","requestAnimationFrame","cancelAnimationFrame","timerIntervalometer","delay","setTimeout","clearTimeout","224"],"mappings":"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","file":"bulbs-cinemagraph.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _register = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(189);\n\t\n\tvar _iphoneInlineVideo = __webpack_require__(221);\n\t\n\tvar iphoneInlineVideo = _interopRequireWildcard(_iphoneInlineVideo);\n\t\n\t__webpack_require__(224);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }\n\t\n\t// We have to do this little dance to properly subclass elements in Safari\n\tfunction BulbsHTMLVideoElement() {}\n\tBulbsHTMLVideoElement.prototype = HTMLVideoElement.prototype;\n\t\n\tvar BulbsCinemagraph = function (_BulbsHTMLVideoElemen) {\n\t  _inherits(BulbsCinemagraph, _BulbsHTMLVideoElemen);\n\t\n\t  function BulbsCinemagraph() {\n\t    _classCallCheck(this, BulbsCinemagraph);\n\t\n\t    return _possibleConstructorReturn(this, _BulbsHTMLVideoElemen.apply(this, arguments));\n\t  }\n\t\n\t  BulbsCinemagraph.prototype.createdCallback = function createdCallback() {\n\t\n\t    // makeVideoPlayableInline is dumb and goes just a little bit too far in the\n\t    // video, this results in a quick flash of a black frame in the loop. If we\n\t    // override the duration we can get the loop to loop properly.\n\t    // For now, this must be determined by hand.\n\t    Object.defineProperty(this, 'duration', {\n\t      get: function get() {\n\t        return parseFloat(this.getAttribute('cinemagraph-duration')) || 0;\n\t      }\n\t    });\n\t  };\n\t\n\t  BulbsCinemagraph.prototype.attachedCallback = function attachedCallback() {\n\t    var _this2 = this;\n\t\n\t    if (!this.hasAttribute('cinemagraph-duration')) {\n\t      console.warn('is=\"bulbs-cinemagraph\" elements should have a [cinemagraph-duration] attribute set');\n\t    }\n\t\n\t    this.setAttribute('loop', true);\n\t    this.setAttribute('webkit-playsinline', true);\n\t\n\t    this.addEventListener('enterviewport', function () {\n\t      return _this2.play();\n\t    });\n\t    this.addEventListener('exitviewport', function () {\n\t      return _this2.pause();\n\t    });\n\t    iphoneInlineVideo.default(this, /* hasAudio */false);\n\t    _util.InViewMonitor.add(this);\n\t  };\n\t\n\t  BulbsCinemagraph.prototype.detachedCallback = function detachedCallback() {\n\t    _util.InViewMonitor.remove(this);\n\t  };\n\t\n\t  return BulbsCinemagraph;\n\t}(BulbsHTMLVideoElement);\n\t\n\tBulbsCinemagraph.extends = 'video';\n\t\n\t(0, _register.registerElement)('bulbs-cinemagraph', BulbsCinemagraph);\n\n/***/ }),\n\n/***/ 221:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*! npm.im/iphone-inline-video */\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar Symbol = _interopDefault(__webpack_require__(222));\n\tvar intervalometer = __webpack_require__(223);\n\t\n\tfunction preventEvent(element, eventName, toggleProperty, preventWithProperty) {\n\t\tfunction handler(e) {\n\t\t\tif (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t// console.log(eventName, 'prevented on', element);\n\t\t\t}\n\t\t\tdelete element[toggleProperty];\n\t\t}\n\t\telement.addEventListener(eventName, handler, false);\n\t\n\t\t// Return handler to allow to disable the prevention. Usage:\n\t\t// const preventionHandler = preventEvent(el, 'click');\n\t\t// el.removeEventHandler('click', preventionHandler);\n\t\treturn handler;\n\t}\n\t\n\tfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\t\tfunction get() {\n\t\t\treturn sourceObject[propertyName];\n\t\t}\n\t\tfunction set(value) {\n\t\t\tsourceObject[propertyName] = value;\n\t\t}\n\t\n\t\tif (copyFirst) {\n\t\t\tset(object[propertyName]);\n\t\t}\n\t\n\t\tObject.defineProperty(object, propertyName, {get: get, set: set});\n\t}\n\t\n\tfunction proxyEvent(object, eventName, sourceObject) {\n\t\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n\t}\n\t\n\tfunction dispatchEventAsync(element, type) {\n\t\tPromise.resolve().then(function () {\n\t\t\telement.dispatchEvent(new Event(type));\n\t\t});\n\t}\n\t\n\t// iOS 10 adds support for native inline playback + silent autoplay\n\tvar isWhitelisted = 'object-fit' in document.head.style && /iPhone|iPod/i.test(navigator.userAgent) && !matchMedia('(-webkit-video-playable-inline)').matches;\n\t\n\tvar ಠ = Symbol();\n\tvar ಠevent = Symbol();\n\tvar ಠplay = Symbol('nativeplay');\n\tvar ಠpause = Symbol('nativepause');\n\t\n\t/**\n\t * UTILS\n\t */\n\t\n\tfunction getAudioFromVideo(video) {\n\t\tvar audio = new Audio();\n\t\tproxyEvent(video, 'play', audio);\n\t\tproxyEvent(video, 'playing', audio);\n\t\tproxyEvent(video, 'pause', audio);\n\t\taudio.crossOrigin = video.crossOrigin;\n\t\n\t\t// 'data:' causes audio.networkState > 0\n\t\t// which then allows to keep <audio> in a resumable playing state\n\t\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\t\taudio.src = video.src || video.currentSrc || 'data:';\n\t\n\t\t// if (audio.src === 'data:') {\n\t\t//   TODO: wait for video to be selected\n\t\t// }\n\t\treturn audio;\n\t}\n\t\n\tvar lastRequests = [];\n\tvar requestIndex = 0;\n\tvar lastTimeupdateEvent;\n\t\n\tfunction setTime(video, time, rememberOnly) {\n\t\t// allow one timeupdate event every 200+ ms\n\t\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\t\tvideo[ಠevent] = true;\n\t\t\tlastTimeupdateEvent = Date.now();\n\t\t}\n\t\tif (!rememberOnly) {\n\t\t\tvideo.currentTime = time;\n\t\t}\n\t\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n\t}\n\t\n\tfunction isPlayerEnded(player) {\n\t\treturn player.driver.currentTime >= player.video.duration;\n\t}\n\t\n\tfunction update(timeDiff) {\n\t\tvar player = this;\n\t\t// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\t\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\t\tif (!player.hasAudio) {\n\t\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetTime(player.video, player.driver.currentTime);\n\t\t} else if (player.video.networkState === player.video.NETWORK_IDLE && !player.video.buffered.length) {\n\t\t\t// this should happen when the source is available but:\n\t\t\t// - it's potentially playing (.paused === false)\n\t\t\t// - it's not ready to play\n\t\t\t// - it's not loading\n\t\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\t\tplayer.video.load();\n\t\t\t// console.log('Will load');\n\t\t}\n\t\n\t\t// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\t\n\t\tif (player.video.ended) {\n\t\t\tdelete player.video[ಠevent]; // allow timeupdate event\n\t\t\tplayer.video.pause(true);\n\t\t}\n\t}\n\t\n\t/**\n\t * METHODS\n\t */\n\t\n\tfunction play() {\n\t\t// console.log('play');\n\t\tvar video = this;\n\t\tvar player = video[ಠ];\n\t\n\t\t// if it's fullscreen, use the native player\n\t\tif (video.webkitDisplayingFullscreen) {\n\t\t\tvideo[ಠplay]();\n\t\t\treturn;\n\t\t}\n\t\n\t\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t\t// console.log('src changed on play', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t}\n\t\n\t\tif (!video.paused) {\n\t\t\treturn;\n\t\t}\n\t\tplayer.paused = false;\n\t\n\t\tif (!video.buffered.length) {\n\t\t\t// .load() causes the emptied event\n\t\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t\t// possibly the alternative is preventing this event only once\n\t\t\tvideo.load();\n\t\t}\n\t\n\t\tplayer.driver.play();\n\t\tplayer.updater.start();\n\t\n\t\tif (!player.hasAudio) {\n\t\t\tdispatchEventAsync(video, 'play');\n\t\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t\t// console.log('onplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t}\n\t}\n\tfunction pause(forceEvents) {\n\t\t// console.log('pause');\n\t\tvar video = this;\n\t\tvar player = video[ಠ];\n\t\n\t\tplayer.driver.pause();\n\t\tplayer.updater.stop();\n\t\n\t\t// if it's fullscreen, the developer the native player.pause()\n\t\t// This is at the end of pause() because it also\n\t\t// needs to make sure that the simulation is paused\n\t\tif (video.webkitDisplayingFullscreen) {\n\t\t\tvideo[ಠpause]();\n\t\t}\n\t\n\t\tif (player.paused && !forceEvents) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tplayer.paused = true;\n\t\tif (!player.hasAudio) {\n\t\t\tdispatchEventAsync(video, 'pause');\n\t\t}\n\t\tif (video.ended) {\n\t\t\tvideo[ಠevent] = true;\n\t\t\tdispatchEventAsync(video, 'ended');\n\t\t}\n\t}\n\t\n\t/**\n\t * SETUP\n\t */\n\t\n\tfunction addPlayer(video, hasAudio) {\n\t\tvar player = video[ಠ] = {};\n\t\tplayer.paused = true; // track whether 'pause' events have been fired\n\t\tplayer.hasAudio = hasAudio;\n\t\tplayer.video = video;\n\t\tplayer.updater = intervalometer.frameIntervalometer(update.bind(player));\n\t\n\t\tif (hasAudio) {\n\t\t\tplayer.driver = getAudioFromVideo(video);\n\t\t} else {\n\t\t\tvideo.addEventListener('canplay', function () {\n\t\t\t\tif (!video.paused) {\n\t\t\t\t\t// console.log('oncanplay');\n\t\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t\t}\n\t\t\t});\n\t\t\tplayer.driver = {\n\t\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\t\tmuted: true,\n\t\t\t\tpaused: true,\n\t\t\t\tpause: function () {\n\t\t\t\t\tplayer.driver.paused = true;\n\t\t\t\t},\n\t\t\t\tplay: function () {\n\t\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t\t// media automatically goes to 0 if .play() is called when it's done\n\t\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tget ended() {\n\t\t\t\t\treturn isPlayerEnded(player);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\t// .load() causes the emptied event\n\t\tvideo.addEventListener('emptied', function () {\n\t\t\t// console.log('driver src is', player.driver.src);\n\t\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t\t// console.log('src changed to', video.src);\n\t\t\t\tsetTime(video, 0, true);\n\t\t\t\tplayer.driver.src = video.src;\n\t\t\t\t// playing videos will only keep playing if no src was present when .play()’ed\n\t\t\t\tif (wasEmpty) {\n\t\t\t\t\tplayer.driver.play();\n\t\t\t\t} else {\n\t\t\t\t\tplayer.updater.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}, false);\n\t\n\t\t// stop programmatic player when OS takes over\n\t\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// make sure that the <audio> and the syncer/updater are stopped\n\t\t\t\tvideo.pause();\n\t\n\t\t\t\t// play video natively\n\t\t\t\tvideo[ಠplay]();\n\t\t\t} else if (hasAudio && !player.driver.buffered.length) {\n\t\t\t\t// if the first play is native,\n\t\t\t\t// the <audio> needs to be buffered manually\n\t\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\t\tplayer.driver.load();\n\t\t\t}\n\t\t});\n\t\tif (hasAudio) {\n\t\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t\t// sync audio to new video position\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t\t// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t\t});\n\t\n\t\t\t// allow seeking\n\t\t\tvideo.addEventListener('seeking', function () {\n\t\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t\t// console.log('User-requested seeking');\n\t\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\tfunction overloadAPI(video) {\n\t\tvar player = video[ಠ];\n\t\tvideo[ಠplay] = video.play;\n\t\tvideo[ಠpause] = video.pause;\n\t\tvideo.play = play;\n\t\tvideo.pause = pause;\n\t\tproxyProperty(video, 'paused', player.driver);\n\t\tproxyProperty(video, 'muted', player.driver, true);\n\t\tproxyProperty(video, 'playbackRate', player.driver, true);\n\t\tproxyProperty(video, 'ended', player.driver);\n\t\tproxyProperty(video, 'loop', player.driver, true);\n\t\tpreventEvent(video, 'seeking');\n\t\tpreventEvent(video, 'seeked');\n\t\tpreventEvent(video, 'timeupdate', ಠevent, false);\n\t\tpreventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events\n\t}\n\t\n\tfunction enableInlineVideo(video, hasAudio, onlyWhitelisted) {\n\t\tif ( hasAudio === void 0 ) hasAudio = true;\n\t\tif ( onlyWhitelisted === void 0 ) onlyWhitelisted = true;\n\t\n\t\tif ((onlyWhitelisted && !isWhitelisted) || video[ಠ]) {\n\t\t\treturn;\n\t\t}\n\t\taddPlayer(video, hasAudio);\n\t\toverloadAPI(video);\n\t\tvideo.classList.add('IIV');\n\t\tif (!hasAudio && video.autoplay) {\n\t\t\tvideo.play();\n\t\t}\n\t\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t\t}\n\t}\n\t\n\tenableInlineVideo.isWhitelisted = isWhitelisted;\n\t\n\tmodule.exports = enableInlineVideo;\n\n/***/ }),\n\n/***/ 222:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar index = typeof Symbol === 'undefined' ? function (description) {\n\t\treturn '@' + (description || '@') + Math.random();\n\t} : Symbol;\n\t\n\tmodule.exports = index;\n\n/***/ }),\n\n/***/ 223:\n/***/ (function(module, exports) {\n\n\t/*! npm.im/intervalometer */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction intervalometer(cb, request, cancel, requestParameter) {\n\t\tvar requestId;\n\t\tvar previousLoopTime;\n\t\tfunction loop(now) {\n\t\t\t// must be requested before cb() because that might call .stop()\n\t\t\trequestId = request(loop, requestParameter);\n\t\n\t\t\t// called with \"ms since last call\". 0 on start()\n\t\t\tcb(now - (previousLoopTime || now));\n\t\n\t\t\tpreviousLoopTime = now;\n\t\t}\n\t\treturn {\n\t\t\tstart: function start() {\n\t\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\t\tloop(0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tstop: function stop() {\n\t\t\t\tcancel(requestId);\n\t\t\t\trequestId = null;\n\t\t\t\tpreviousLoopTime = 0;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction frameIntervalometer(cb) {\n\t\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n\t}\n\t\n\tfunction timerIntervalometer(cb, delay) {\n\t\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n\t}\n\t\n\texports.intervalometer = intervalometer;\n\texports.frameIntervalometer = frameIntervalometer;\n\texports.timerIntervalometer = timerIntervalometer;\n\n/***/ }),\n\n/***/ 224:\n/***/ (function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// bulbs-cinemagraph.js","import { registerElement } from 'bulbs-elements/register';\nimport { InViewMonitor } from 'bulbs-elements/util';\nimport * as iphoneInlineVideo from 'iphone-inline-video';\nimport './bulbs-cinemagraph.scss';\n\n// We have to do this little dance to properly subclass elements in Safari\nfunction BulbsHTMLVideoElement () {}\nBulbsHTMLVideoElement.prototype = HTMLVideoElement.prototype;\n\nclass BulbsCinemagraph extends BulbsHTMLVideoElement {\n\n  createdCallback () {\n\n    // makeVideoPlayableInline is dumb and goes just a little bit too far in the\n    // video, this results in a quick flash of a black frame in the loop. If we\n    // override the duration we can get the loop to loop properly.\n    // For now, this must be determined by hand.\n    Object.defineProperty(this, 'duration', {\n      get () {\n        return parseFloat(this.getAttribute('cinemagraph-duration')) || 0;\n      },\n    });\n  }\n\n  attachedCallback () {\n    if (!this.hasAttribute('cinemagraph-duration')) {\n      console.warn('is=\"bulbs-cinemagraph\" elements should have a [cinemagraph-duration] attribute set');\n    }\n\n    this.setAttribute('loop', true);\n    this.setAttribute('webkit-playsinline', true);\n\n    this.addEventListener('enterviewport', () => this.play());\n    this.addEventListener('exitviewport', () => this.pause());\n    iphoneInlineVideo.default(this, /* hasAudio */ false);\n    InViewMonitor.add(this);\n  }\n\n  detachedCallback () {\n    InViewMonitor.remove(this);\n  }\n}\n\nBulbsCinemagraph.extends = 'video';\n\nregisterElement('bulbs-cinemagraph', BulbsCinemagraph);\n\n\n\n// WEBPACK FOOTER //\n// ./elements/bulbs-cinemagraph/bulbs-cinemagraph.js","/*! npm.im/iphone-inline-video */\n'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Symbol = _interopDefault(require('poor-mans-symbol'));\nvar intervalometer = require('intervalometer');\n\nfunction preventEvent(element, eventName, toggleProperty, preventWithProperty) {\n\tfunction handler(e) {\n\t\tif (Boolean(element[toggleProperty]) === Boolean(preventWithProperty)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// console.log(eventName, 'prevented on', element);\n\t\t}\n\t\tdelete element[toggleProperty];\n\t}\n\telement.addEventListener(eventName, handler, false);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\n// iOS 10 adds support for native inline playback + silent autoplay\nvar isWhitelisted = 'object-fit' in document.head.style && /iPhone|iPod/i.test(navigator.userAgent) && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar ಠ = Symbol();\nvar ಠevent = Symbol();\nvar ಠplay = Symbol('nativeplay');\nvar ಠpause = Symbol('nativepause');\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[ಠevent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && !player.video.buffered.length) {\n\t\t// this should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// console.log('Will load');\n\t}\n\n\t// console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[ಠevent]; // allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// console.log('play');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\t// if it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠplay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (!video.buffered.length) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// console.log('pause');\n\tvar video = this;\n\tvar player = video[ಠ];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// if it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[ಠpause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\tif (video.ended) {\n\t\tvideo[ಠevent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = video[ಠ] = {};\n\tplayer.paused = true; // track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = intervalometer.frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// playing videos will only keep playing if no src was present when .play()’ed\n\t\t\tif (wasEmpty) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// play video natively\n\t\t\tvideo[ಠplay]();\n\t\t} else if (hasAudio && !player.driver.buffered.length) {\n\t\t\t// if the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[ಠ];\n\tvideo[ಠplay] = video.play;\n\tvideo[ಠpause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\tpreventEvent(video, 'seeking');\n\tpreventEvent(video, 'seeked');\n\tpreventEvent(video, 'timeupdate', ಠevent, false);\n\tpreventEvent(video, 'ended', ಠevent, false); // prevent occasional native ended events\n}\n\nfunction enableInlineVideo(video, hasAudio, onlyWhitelisted) {\n\tif ( hasAudio === void 0 ) hasAudio = true;\n\tif ( onlyWhitelisted === void 0 ) onlyWhitelisted = true;\n\n\tif ((onlyWhitelisted && !isWhitelisted) || video[ಠ]) {\n\t\treturn;\n\t}\n\taddPlayer(video, hasAudio);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\tif (!hasAudio && video.autoplay) {\n\t\tvideo.play();\n\t}\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nenableInlineVideo.isWhitelisted = isWhitelisted;\n\nmodule.exports = enableInlineVideo;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/iphone-inline-video/dist/iphone-inline-video.common-js.js\n// module id = 221\n// module chunks = 2","'use strict';\n\nvar index = typeof Symbol === 'undefined' ? function (description) {\n\treturn '@' + (description || '@') + Math.random();\n} : Symbol;\n\nmodule.exports = index;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/poor-mans-symbol/dist/poor-mans-symbol.common-js.js\n// module id = 222\n// module chunks = 2","/*! npm.im/intervalometer */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\nexports.intervalometer = intervalometer;\nexports.frameIntervalometer = frameIntervalometer;\nexports.timerIntervalometer = timerIntervalometer;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/intervalometer/dist/intervalometer.common-js.js\n// module id = 223\n// module chunks = 2"],"sourceRoot":""}
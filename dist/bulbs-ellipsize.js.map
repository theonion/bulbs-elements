{"version":3,"sources":["webpack:///bulbs-ellipsize.js","webpack:///./elements/bulbs-ellipsize/bulbs-ellipsize.js","webpack:///./~/truncate.js/truncate.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_defaults","defaults","keys","Object","getOwnPropertyNames","i","length","key","value","getOwnPropertyDescriptor","configurable","undefined","defineProperty","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","setPrototypeOf","_register","_invariant","_invariant2","_truncate","BulbsEllipsize","_BulbsHTMLElement","this","apply","arguments","attachedCallback","getAttribute","textContent","truncate","lineCount","parseInt","$","lines","ellipsis","BulbsHTMLElement","registerElement","217","trimRight","text","replace","setText","element","innerText","nodeValue","truncateNearestSibling","$element","$rootNode","$clipNode","options","$prevSibling","$parent","parent","remove","clipLength","contents","eq","truncateTextContent","$parentSibling","prev","append","truncateTextStart","mid","chunk","original","maxChunk","low","high","substr","height","maxHeight","truncateTextEnd","truncateTextMiddle","len","position","truncateNestedNodeStart","$child","child","$children","index","truncated","empty","nodeType","insertBefore","firstChild","inArray","tagName","toLowerCase","BLOCK_TAGS","after","truncateNestedNode","truncateNestedNodeEnd","appendChild","Truncate","_name","showMore","showLess","lineHeight","extend","lineHeightCss","css","parseHTML","cached","innerHTML","isTruncated","isCollapsed","update","html","wasExpanded","$wrap","wrapInner","children","border","margin","padding","width","word-wrap","isExplicitlyCollapsed","replaceWith","expand","includeShowLess","collapse","retruncate","fn","args","makeArray","slice","each","data","jQuery"],"mappings":"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","file":"bulbs-ellipsize.js","sourcesContent":["webpackJsonp([7],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _register = __webpack_require__(2);\n\t\n\tvar _invariant = __webpack_require__(1);\n\t\n\tvar _invariant2 = _interopRequireDefault(_invariant);\n\t\n\tvar _truncate = __webpack_require__(217);\n\t\n\tvar _truncate2 = _interopRequireDefault(_truncate);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }\n\t\n\t// eslint-disable-line no-unused-vars\n\t\n\tvar BulbsEllipsize = function (_BulbsHTMLElement) {\n\t  _inherits(BulbsEllipsize, _BulbsHTMLElement);\n\t\n\t  function BulbsEllipsize() {\n\t    _classCallCheck(this, BulbsEllipsize);\n\t\n\t    return _possibleConstructorReturn(this, _BulbsHTMLElement.apply(this, arguments));\n\t  }\n\t\n\t  BulbsEllipsize.prototype.attachedCallback = function attachedCallback() {\n\t    (0, _invariant2.default)(this.getAttribute('line-count'), 'BulbsEllipsize: Expects a line-count attribute');\n\t    if (!this.textContent) {\n\t      return;\n\t    }\n\t\n\t    this.truncate();\n\t  };\n\t\n\t  BulbsEllipsize.prototype.truncate = function truncate() {\n\t    var lineCount = parseInt(this.getAttribute('line-count'), 10);\n\t\n\t    $(this).truncate({ lines: lineCount, ellipsis: '...' });\n\t  };\n\t\n\t  return BulbsEllipsize;\n\t}(_register.BulbsHTMLElement);\n\t\n\t(0, _register.registerElement)('bulbs-ellipsize', BulbsEllipsize);\n\texports.default = BulbsEllipsize;\n\n/***/ },\n\n/***/ 217:\n/***/ function(module, exports) {\n\n\t(function (module, $, undefined) {\n\t\n\t  var BLOCK_TAGS = ['table', 'thead', 'tbody', 'tfoot', 'tr', 'col', 'colgroup', 'object', 'embed', 'param', 'ol', 'ul', 'dl', 'blockquote', 'select', 'optgroup', 'option', 'textarea', 'script', 'style'];\n\t\n\t  /* Trim function.\n\t   * Trim only end of string whitespaces\n\t   *\n\t   * text - String to trim\n\t   *\n\t   * Returns text without end whitespaces\n\t   */\n\t  function trimRight(text) {\n\t    return text.replace(/\\s*$/,\"\");\n\t  }\n\t\n\t  function setText(element, text) {\n\t    if (element.innerText) {\n\t      element.innerText = text;\n\t    } else if (element.nodeValue) {\n\t      element.nodeValue = text;\n\t    } else if (element.textContent) {\n\t      element.textContent = text;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  /* Truncate the nearest sibling node.\n\t   * If no valid immediate sibling is found, traverse one level up to a cousin node.\n\t   *\n\t   * $element  - The jQuery node to truncate.\n\t   * $rootNode - The jQuery root node to measure the truncated height.\n\t   * $clipNode - The jQuery node to insert right after the truncation point.\n\t   * options   - An object containing:\n\t   *             ellipsis  - The ellipsis string to append at the end of the truncation.\n\t   *             maxHeight - The maximum height for the root node (in px).\n\t   *             position  - The position of the truncation (\"start\", \"middle\", \"end\").\n\t   *\n\t   * Returns true if truncation happened, false otherwise.\n\t   */\n\t  function truncateNearestSibling($element, $rootNode, $clipNode, options) {\n\t    var $parent = $element.parent();\n\t    var $prevSibling;\n\t\n\t    $element.remove();\n\t\n\t    // Take into account length of $clipNode element previous inserted.\n\t    var clipLength = $clipNode ? $clipNode.length : 0;\n\t\n\t    if ($parent.contents().length > clipLength) {\n\t\n\t      // Valid previous sibling element (sharing same parent node) exists,\n\t      // so attempt to truncate it.\n\t      $prevSibling = $parent.contents().eq(-1 - clipLength);\n\t      return truncateTextContent($prevSibling, $rootNode, $clipNode, options);\n\t\n\t    } else {\n\t\n\t      // No previous sibling element (sharing same parent node) exists.\n\t      // Therefore, search parent's sibling.\n\t\n\t      var $parentSibling = $parent.prev();\n\t      $prevSibling = $parentSibling.contents().eq(-1);\n\t\n\t      if ($prevSibling.length) {\n\t\n\t        // Because traversal is in-order so the algorithm already checked that\n\t        // this point meets the height requirement. As such, it's safe to truncate here.\n\t        setText($prevSibling[0], $prevSibling.text() + options.ellipsis);\n\t        $parent.remove();\n\t\n\t        if ($clipNode.length) {\n\t          $parentSibling.append($clipNode);\n\t        }\n\t        return true;\n\t      }\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  /* Truncates, at the beginning, the text content of a node using binary search */\n\t  function truncateTextStart($element, $rootNode, $clipNode, options) {\n\t    var element = $element[0];\n\t    var original = $element.text();\n\t\n\t    var maxChunk = '';\n\t    var mid, chunk;\n\t    var low = 0;\n\t    var high = original.length;\n\t\n\t    while (low <= high) {\n\t      mid = low + ((high - low) >> 1); // Integer division\n\t\n\t      chunk = options.ellipsis + trimRight(original.substr(mid - 1, original.length));\n\t      setText(element, chunk);\n\t\n\t      if ($rootNode.height() > options.maxHeight) {\n\t        // too big, reduce the chunk\n\t        low = mid + 1;\n\t      }\n\t      else {\n\t        // chunk valid, try to get a bigger chunk\n\t        high = mid - 1;\n\t        maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;\n\t      }\n\t    }\n\t\n\t    if (maxChunk.length > 0) {\n\t      setText(element, maxChunk);\n\t      return true;\n\t    } else {\n\t      return truncateNearestSibling($element, $rootNode, $clipNode, options);\n\t    }\n\t  }\n\t\n\t  /* Truncates, at the end, the text content of a node using binary search */\n\t  function truncateTextEnd($element, $rootNode, $clipNode, options) {\n\t    var element = $element[0];\n\t    var original = $element.text();\n\t\n\t    var maxChunk = '';\n\t    var mid, chunk;\n\t    var low = 0;\n\t    var high = original.length;\n\t\n\t    // Binary Search\n\t    while (low <= high) {\n\t      mid = low + ((high - low) >> 1); // Integer division\n\t\n\t      chunk = trimRight(original.substr(0, mid + 1)) + options.ellipsis;\n\t      setText(element, chunk);\n\t\n\t      if ($rootNode.height() > options.maxHeight) {\n\t        // too big, reduce the chunk\n\t        high = mid - 1;\n\t      } else {\n\t        // chunk valid, try to get a bigger chunk\n\t        low = mid + 1;\n\t        maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;\n\t      }\n\t    }\n\t\n\t    if (maxChunk.length > 0) {\n\t      setText(element, maxChunk);\n\t      return true;\n\t    } else {\n\t      return truncateNearestSibling($element, $rootNode, $clipNode, options);\n\t    }\n\t  }\n\t\n\t  /* Truncates, at the middle, the text content of a node using binary search */\n\t  function truncateTextMiddle($element, $rootNode, $clipNode, options) {\n\t    var element = $element[0];\n\t    var original = $element.text();\n\t\n\t    var maxChunk = '';\n\t    var low = 0;\n\t    var len = original.length;\n\t    var high = len >> 1;\n\t    var mid, chunk;\n\t\n\t    while (low <= high) {\n\t      mid = low + ((high - low) >> 1); // Integer division\n\t\n\t      chunk = trimRight(original.substr(0, mid)) + options.ellipsis + original.substr(len - mid, len - mid);\n\t      setText(element, chunk);\n\t\n\t      if ($rootNode.height() > options.maxHeight) {\n\t        // too big, reduce the chunk\n\t        high = mid - 1;\n\t      }\n\t      else {\n\t        // chunk valid, try to get a bigger chunk\n\t        low = mid + 1;\n\t\n\t        maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;\n\t      }\n\t    }\n\t\n\t    if (maxChunk.length > 0) {\n\t      setText(element, maxChunk);\n\t      return true;\n\t    } else {\n\t      return truncateNearestSibling($element, $rootNode, $clipNode, options);\n\t    }\n\t  }\n\t\n\t  /* Truncates the text content of a node using binary search.\n\t   * If no valid truncation point is found, attempt to truncate its nearest sibling.\n\t   *\n\t   * $textNode - The jQuery node to truncate.\n\t   * $rootNode - The jQuery root node to measure the truncated height.\n\t   * $clipNode - The jQuery node to insert right after the truncation point.\n\t   * options   - An object containing:\n\t   *             ellipsis  - The ellipsis string to append at the end of the truncation.\n\t   *             maxHeight - The maximum height for the root node (in px).\n\t   *             position  - The position of the truncation (\"start\", \"middle\", \"end\").\n\t   *\n\t   * Returns true if truncation happened, false otherwise.\n\t   */\n\t  function truncateTextContent($element, $rootNode, $clipNode, options) { // jshint ignore:line\n\t    if (options.position === \"end\") {\n\t      return truncateTextEnd($element, $rootNode, $clipNode, options);\n\t    }\n\t    else if (options.position === \"start\") {\n\t      return truncateTextStart($element, $rootNode, $clipNode, options);\n\t    }\n\t    else {\n\t      return truncateTextMiddle($element, $rootNode, $clipNode, options);\n\t    }\n\t  }\n\t\n\t  /* Recursively truncates a nested node. Traverses the children node tree in reverse order. */\n\t  function truncateNestedNodeStart($element, $rootNode, $clipNode, options) {\n\t    var element = $element[0];\n\t\n\t    var $children = $element.contents();\n\t    var $child, child;\n\t\n\t    var length = $children.length;\n\t    var index = length -1;\n\t    var truncated = false;\n\t\n\t    $element.empty();\n\t\n\t    for (; index >= 0 && !truncated; index--) {\n\t\n\t      $child = $children.eq(index);\n\t      child = $child[0];\n\t\n\t      if (child.nodeType === 8) { // comment node\n\t        continue;\n\t      }\n\t\n\t      element.insertBefore(child, element.firstChild);\n\t\n\t      if ($clipNode.length) {\n\t        if ($.inArray(element.tagName.toLowerCase(), BLOCK_TAGS) >= 0) {\n\t          // Certain elements like <li> should not be appended to.\n\t          $element.after($clipNode);\n\t        } else {\n\t          $element.append($clipNode);\n\t        }\n\t      }\n\t\n\t      if ($rootNode.height() > options.maxHeight) {\n\t        if (child.nodeType === 3) { // text node\n\t          truncated = truncateTextContent($child, $rootNode, $clipNode, options);\n\t        } else {\n\t          truncated = truncateNestedNode($child, $rootNode, $clipNode, options);\n\t        }\n\t      }\n\t\n\t      if (!truncated && $clipNode.length) {\n\t        $clipNode.remove();\n\t      }\n\t\n\t    }\n\t\n\t    return truncated;\n\t  }\n\t\n\t  /* Recursively truncates a nested node. Traverses the children node tree in-order. */\n\t  function truncateNestedNodeEnd($element, $rootNode, $clipNode, options) {\n\t    var element = $element[0];\n\t\n\t    var $children = $element.contents();\n\t    var $child, child;\n\t\n\t    var index = 0;\n\t    var length = $children.length;\n\t    var truncated = false;\n\t\n\t    $element.empty();\n\t\n\t    for (; index < length && !truncated; index++) {\n\t\n\t      $child = $children.eq(index);\n\t      child = $child[0];\n\t\n\t      if (child.nodeType === 8) { // comment node\n\t        continue;\n\t      }\n\t\n\t      element.appendChild(child);\n\t\n\t      if ($clipNode.length) {\n\t        if ($.inArray(element.tagName.toLowerCase(), BLOCK_TAGS) >= 0) {\n\t          // Certain elements like <li> should not be appended to.\n\t          $element.after($clipNode);\n\t        } else {\n\t          $element.append($clipNode);\n\t        }\n\t      }\n\t\n\t      if ($rootNode.height() > options.maxHeight) {\n\t        if (child.nodeType === 3) { // text node\n\t          truncated = truncateTextContent($child, $rootNode, $clipNode, options);\n\t        } else {\n\t          truncated = truncateNestedNode($child, $rootNode, $clipNode, options);\n\t        }\n\t      }\n\t\n\t      if (!truncated && $clipNode.length) {\n\t        $clipNode.remove();\n\t      }\n\t\n\t    }\n\t\n\t    return truncated;\n\t  }\n\t\n\t  /* Recursively truncates a nested node.\n\t   *\n\t   * $element  - The jQuery nested node to truncate.\n\t   * $rootNode - The jQuery root node to measure the truncated height.\n\t   * $clipNode - The jQuery node to insert right after the truncation point.\n\t   * options   - An object containing:\n\t   *             ellipsis  - The ellipsis string to append at the end of the truncation.\n\t   *             maxHeight - The maximum height for the root node (in px).\n\t   *             position  - The position of the truncation (\"start\", \"middle\", \"end\").\n\t   *\n\t   * Returns true if truncation happened, false otherwise.\n\t   */\n\t  function truncateNestedNode($element, $rootNode, $clipNode, options) { // jshint ignore:line\n\t    if (options.position === \"end\") {\n\t      return truncateNestedNodeEnd($element, $rootNode, $clipNode, options);\n\t    }\n\t    else if (options.position === \"start\") {\n\t      return truncateNestedNodeStart($element, $rootNode, $clipNode, options);\n\t    }\n\t    else {\n\t      // TODO: Truncate middle for nested = HARDCORE\n\t      return truncateNestedNodeEnd($element, $rootNode, $clipNode, options);\n\t    }\n\t  }\n\t\n\t  /* Public: Creates an instance of Truncate.\n\t   *\n\t   * element - A DOM element to be truncated.\n\t   * options - An Object literal containing setup options.\n\t   *\n\t   * Examples:\n\t   *\n\t   *   var element = document.createElement('span');\n\t   *   element.innerHTML = 'This is<br>odd.';\n\t   *   var truncated = new Truncate(element, {\n\t   *     lines: 1,\n\t   *     lineHeight: 16,\n\t   *     ellipsis: '… ',\n\t   *     showMore: '<a class=\"show-more\">Show More</a>',\n\t   *     showLess: '<a class=\"show-less\">Show Less</a>',\n\t   *     position: \"start\"\n\t   *   });\n\t   *\n\t   *   // Update HTML\n\t   *   truncated.update('This is not very odd.');\n\t   *\n\t   *   // Undo truncation\n\t   *   truncated.expand();\n\t   *\n\t   *   // Redo truncation\n\t   *   truncated.collapse();\n\t   */\n\t  function Truncate(element, options) {\n\t    this.element = element;\n\t    this.$element = $(element);\n\t\n\t    this._name = 'truncate';\n\t    this._defaults = {\n\t      lines: 1,\n\t      ellipsis: '…',\n\t      showMore: '',\n\t      showLess: '',\n\t      position: 'end',\n\t      lineHeight: 'auto'\n\t    };\n\t\n\t    this.options = $.extend({}, this._defaults, options);\n\t\n\t    if (this.options.lineHeight === 'auto') {\n\t      var lineHeightCss = this.$element.css('line-height'),\n\t        lineHeight = 18; // for Normal we return the default value: 18px\n\t\n\t      if (lineHeightCss !== \"normal\") {\n\t        lineHeight = parseInt(lineHeightCss, 10);\n\t      }\n\t\n\t      this.options.lineHeight = lineHeight;\n\t    }\n\t\n\t    if (this.options.maxHeight === undefined) {\n\t      this.options.maxHeight = parseInt(this.options.lines, 10) * parseInt(this.options.lineHeight, 10);\n\t    }\n\t\n\t    if (this.options.position !== 'start' && this.options.position !== 'middle' && this.options.position !== 'end') {\n\t      this.options.position = 'end';\n\t    }\n\t\n\t    this.$clipNode = $($.parseHTML(this.options.showMore), this.$element);\n\t\n\t    this.original = this.cached = element.innerHTML;\n\t\n\t    this.isTruncated = false; // True if the original content overflows the container.\n\t    this.isCollapsed = true;  // True if the container is currently collapsed.\n\t\n\t    this.update();\n\t  }\n\t\n\t  Truncate.prototype = {\n\t\n\t    /* Public: Updates the inner HTML of the element and re-truncates. Will not\n\t     * perform an updade if the container is currently expanded, instead it\n\t     * will wait until the next time .collapse() is called.\n\t     *\n\t     * html - The new HTML.\n\t     *\n\t     * Returns nothing.\n\t     */\n\t    update: function (html) {\n\t      var wasExpanded = !this.isCollapsed;\n\t\n\t      // Update HTML if provided, otherwise use the current html and restore\n\t      // the truncated content to the original if it's currently present.\n\t      if (typeof html !== 'undefined') {\n\t        this.original = this.element.innerHTML = html;\n\t      } else if (this.isCollapsed && this.element.innerHTML === this.cached) {\n\t        this.element.innerHTML = this.original;\n\t      }\n\t\n\t      // Wrap the contents in order to ignore container's margin/padding.\n\t      var $wrap = this.$element.wrapInner('<div/>').children();\n\t      $wrap.css({\n\t        border: 'none',\n\t        margin: 0,\n\t        padding: 0,\n\t        width: 'auto',\n\t        height: 'auto',\n\t        'word-wrap': 'break-word'\n\t      });\n\t\n\t      this.isTruncated = false;\n\t      // Check if already meets height requirement\n\t      if ($wrap.height() > this.options.maxHeight) {\n\t        this.isTruncated = truncateNestedNode($wrap, $wrap, this.$clipNode, this.options);\n\t\n\t        if(this.isExplicitlyCollapsed) {\n\t          this.isCollapsed = true;\n\t          wasExpanded = false;\n\t        }\n\t      } else {\n\t        this.isCollapsed = false;\n\t      }\n\t\n\t      // Restore the wrapped contents\n\t      $wrap.replaceWith($wrap.contents());\n\t\n\t      // Cache the truncated content\n\t      this.cached = this.element.innerHTML;\n\t\n\t      // If the container was expanded when .update() was called then restore\n\t      // it to it's previous state.\n\t      if (wasExpanded) {\n\t        this.element.innerHTML = this.original;\n\t      }\n\t    },\n\t\n\t    /* Public: Expands the element to show content in full.\n\t     *\n\t     * Returns nothing.\n\t     */\n\t    expand: function () {\n\t      var includeShowLess = true;\n\t\n\t      if(this.isExplicitlyCollapsed) {\n\t        this.isExplicitlyCollapsed = false;\n\t        includeShowLess = false;\n\t      }\n\t\n\t      if (!this.isCollapsed) {\n\t        return;\n\t      }\n\t\n\t      this.isCollapsed = false;\n\t\n\t      this.element.innerHTML = this.isTruncated ? this.original + (includeShowLess ? this.options.showLess : \"\") : this.original;\n\t    },\n\t\n\t    /* Public: Collapses the element to the truncated state.\n\t     * Uses the cached HTML from .update() by default.\n\t     *\n\t     * retruncate - True to retruncate original HTML, otherwise use cached HTML.\n\t     *\n\t     * Returns nothing.\n\t     */\n\t    collapse: function (retruncate) {\n\t      this.isExplicitlyCollapsed = true;\n\t      \n\t      if (this.isCollapsed) {\n\t        return;\n\t      }\n\t\n\t      this.isCollapsed = true;\n\t\n\t      retruncate = retruncate || false;\n\t      if (retruncate) {\n\t        this.update();\n\t      } else {\n\t        this.element.innerHTML = this.cached;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Lightweight plugin wrapper preventing multiple instantiations\n\t  $.fn.truncate = function (options) {\n\t    var args = $.makeArray(arguments).slice(1);\n\t    return this.each(function () {\n\t      var truncate = $.data(this, 'jquery-truncate');\n\t      if (!truncate) {\n\t        $.data(this, 'jquery-truncate', new Truncate(this, options));\n\t      } else if (typeof truncate[options] === 'function') {\n\t        truncate[options].apply(truncate, args);\n\t      }\n\t    });\n\t  };\n\t\n\t  module.Truncate = Truncate;\n\t\n\t})(this, jQuery);\n\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** bulbs-ellipsize.js\n **/","import { BulbsHTMLElement, registerElement } from 'bulbs-elements/register';\nimport invariant from 'invariant';\nimport truncate from 'truncate.js'; // eslint-disable-line no-unused-vars\n\nclass BulbsEllipsize extends BulbsHTMLElement {\n  attachedCallback () {\n    invariant(this.getAttribute('line-count'),\n      'BulbsEllipsize: Expects a line-count attribute');\n    if (!this.textContent) { return; }\n\n    this.truncate();\n  }\n\n  truncate () {\n    let lineCount = parseInt(this.getAttribute('line-count'), 10);\n\n    $(this).truncate({ lines: lineCount, ellipsis: '...' });\n  }\n}\n\nregisterElement('bulbs-ellipsize', BulbsEllipsize);\nexport default BulbsEllipsize;\n\n\n\n/** WEBPACK FOOTER **\n ** ./elements/bulbs-ellipsize/bulbs-ellipsize.js\n **/","(function (module, $, undefined) {\n\n  var BLOCK_TAGS = ['table', 'thead', 'tbody', 'tfoot', 'tr', 'col', 'colgroup', 'object', 'embed', 'param', 'ol', 'ul', 'dl', 'blockquote', 'select', 'optgroup', 'option', 'textarea', 'script', 'style'];\n\n  /* Trim function.\n   * Trim only end of string whitespaces\n   *\n   * text - String to trim\n   *\n   * Returns text without end whitespaces\n   */\n  function trimRight(text) {\n    return text.replace(/\\s*$/,\"\");\n  }\n\n  function setText(element, text) {\n    if (element.innerText) {\n      element.innerText = text;\n    } else if (element.nodeValue) {\n      element.nodeValue = text;\n    } else if (element.textContent) {\n      element.textContent = text;\n    } else {\n      return false;\n    }\n  }\n\n  /* Truncate the nearest sibling node.\n   * If no valid immediate sibling is found, traverse one level up to a cousin node.\n   *\n   * $element  - The jQuery node to truncate.\n   * $rootNode - The jQuery root node to measure the truncated height.\n   * $clipNode - The jQuery node to insert right after the truncation point.\n   * options   - An object containing:\n   *             ellipsis  - The ellipsis string to append at the end of the truncation.\n   *             maxHeight - The maximum height for the root node (in px).\n   *             position  - The position of the truncation (\"start\", \"middle\", \"end\").\n   *\n   * Returns true if truncation happened, false otherwise.\n   */\n  function truncateNearestSibling($element, $rootNode, $clipNode, options) {\n    var $parent = $element.parent();\n    var $prevSibling;\n\n    $element.remove();\n\n    // Take into account length of $clipNode element previous inserted.\n    var clipLength = $clipNode ? $clipNode.length : 0;\n\n    if ($parent.contents().length > clipLength) {\n\n      // Valid previous sibling element (sharing same parent node) exists,\n      // so attempt to truncate it.\n      $prevSibling = $parent.contents().eq(-1 - clipLength);\n      return truncateTextContent($prevSibling, $rootNode, $clipNode, options);\n\n    } else {\n\n      // No previous sibling element (sharing same parent node) exists.\n      // Therefore, search parent's sibling.\n\n      var $parentSibling = $parent.prev();\n      $prevSibling = $parentSibling.contents().eq(-1);\n\n      if ($prevSibling.length) {\n\n        // Because traversal is in-order so the algorithm already checked that\n        // this point meets the height requirement. As such, it's safe to truncate here.\n        setText($prevSibling[0], $prevSibling.text() + options.ellipsis);\n        $parent.remove();\n\n        if ($clipNode.length) {\n          $parentSibling.append($clipNode);\n        }\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Truncates, at the beginning, the text content of a node using binary search */\n  function truncateTextStart($element, $rootNode, $clipNode, options) {\n    var element = $element[0];\n    var original = $element.text();\n\n    var maxChunk = '';\n    var mid, chunk;\n    var low = 0;\n    var high = original.length;\n\n    while (low <= high) {\n      mid = low + ((high - low) >> 1); // Integer division\n\n      chunk = options.ellipsis + trimRight(original.substr(mid - 1, original.length));\n      setText(element, chunk);\n\n      if ($rootNode.height() > options.maxHeight) {\n        // too big, reduce the chunk\n        low = mid + 1;\n      }\n      else {\n        // chunk valid, try to get a bigger chunk\n        high = mid - 1;\n        maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;\n      }\n    }\n\n    if (maxChunk.length > 0) {\n      setText(element, maxChunk);\n      return true;\n    } else {\n      return truncateNearestSibling($element, $rootNode, $clipNode, options);\n    }\n  }\n\n  /* Truncates, at the end, the text content of a node using binary search */\n  function truncateTextEnd($element, $rootNode, $clipNode, options) {\n    var element = $element[0];\n    var original = $element.text();\n\n    var maxChunk = '';\n    var mid, chunk;\n    var low = 0;\n    var high = original.length;\n\n    // Binary Search\n    while (low <= high) {\n      mid = low + ((high - low) >> 1); // Integer division\n\n      chunk = trimRight(original.substr(0, mid + 1)) + options.ellipsis;\n      setText(element, chunk);\n\n      if ($rootNode.height() > options.maxHeight) {\n        // too big, reduce the chunk\n        high = mid - 1;\n      } else {\n        // chunk valid, try to get a bigger chunk\n        low = mid + 1;\n        maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;\n      }\n    }\n\n    if (maxChunk.length > 0) {\n      setText(element, maxChunk);\n      return true;\n    } else {\n      return truncateNearestSibling($element, $rootNode, $clipNode, options);\n    }\n  }\n\n  /* Truncates, at the middle, the text content of a node using binary search */\n  function truncateTextMiddle($element, $rootNode, $clipNode, options) {\n    var element = $element[0];\n    var original = $element.text();\n\n    var maxChunk = '';\n    var low = 0;\n    var len = original.length;\n    var high = len >> 1;\n    var mid, chunk;\n\n    while (low <= high) {\n      mid = low + ((high - low) >> 1); // Integer division\n\n      chunk = trimRight(original.substr(0, mid)) + options.ellipsis + original.substr(len - mid, len - mid);\n      setText(element, chunk);\n\n      if ($rootNode.height() > options.maxHeight) {\n        // too big, reduce the chunk\n        high = mid - 1;\n      }\n      else {\n        // chunk valid, try to get a bigger chunk\n        low = mid + 1;\n\n        maxChunk = maxChunk.length > chunk.length ? maxChunk : chunk;\n      }\n    }\n\n    if (maxChunk.length > 0) {\n      setText(element, maxChunk);\n      return true;\n    } else {\n      return truncateNearestSibling($element, $rootNode, $clipNode, options);\n    }\n  }\n\n  /* Truncates the text content of a node using binary search.\n   * If no valid truncation point is found, attempt to truncate its nearest sibling.\n   *\n   * $textNode - The jQuery node to truncate.\n   * $rootNode - The jQuery root node to measure the truncated height.\n   * $clipNode - The jQuery node to insert right after the truncation point.\n   * options   - An object containing:\n   *             ellipsis  - The ellipsis string to append at the end of the truncation.\n   *             maxHeight - The maximum height for the root node (in px).\n   *             position  - The position of the truncation (\"start\", \"middle\", \"end\").\n   *\n   * Returns true if truncation happened, false otherwise.\n   */\n  function truncateTextContent($element, $rootNode, $clipNode, options) { // jshint ignore:line\n    if (options.position === \"end\") {\n      return truncateTextEnd($element, $rootNode, $clipNode, options);\n    }\n    else if (options.position === \"start\") {\n      return truncateTextStart($element, $rootNode, $clipNode, options);\n    }\n    else {\n      return truncateTextMiddle($element, $rootNode, $clipNode, options);\n    }\n  }\n\n  /* Recursively truncates a nested node. Traverses the children node tree in reverse order. */\n  function truncateNestedNodeStart($element, $rootNode, $clipNode, options) {\n    var element = $element[0];\n\n    var $children = $element.contents();\n    var $child, child;\n\n    var length = $children.length;\n    var index = length -1;\n    var truncated = false;\n\n    $element.empty();\n\n    for (; index >= 0 && !truncated; index--) {\n\n      $child = $children.eq(index);\n      child = $child[0];\n\n      if (child.nodeType === 8) { // comment node\n        continue;\n      }\n\n      element.insertBefore(child, element.firstChild);\n\n      if ($clipNode.length) {\n        if ($.inArray(element.tagName.toLowerCase(), BLOCK_TAGS) >= 0) {\n          // Certain elements like <li> should not be appended to.\n          $element.after($clipNode);\n        } else {\n          $element.append($clipNode);\n        }\n      }\n\n      if ($rootNode.height() > options.maxHeight) {\n        if (child.nodeType === 3) { // text node\n          truncated = truncateTextContent($child, $rootNode, $clipNode, options);\n        } else {\n          truncated = truncateNestedNode($child, $rootNode, $clipNode, options);\n        }\n      }\n\n      if (!truncated && $clipNode.length) {\n        $clipNode.remove();\n      }\n\n    }\n\n    return truncated;\n  }\n\n  /* Recursively truncates a nested node. Traverses the children node tree in-order. */\n  function truncateNestedNodeEnd($element, $rootNode, $clipNode, options) {\n    var element = $element[0];\n\n    var $children = $element.contents();\n    var $child, child;\n\n    var index = 0;\n    var length = $children.length;\n    var truncated = false;\n\n    $element.empty();\n\n    for (; index < length && !truncated; index++) {\n\n      $child = $children.eq(index);\n      child = $child[0];\n\n      if (child.nodeType === 8) { // comment node\n        continue;\n      }\n\n      element.appendChild(child);\n\n      if ($clipNode.length) {\n        if ($.inArray(element.tagName.toLowerCase(), BLOCK_TAGS) >= 0) {\n          // Certain elements like <li> should not be appended to.\n          $element.after($clipNode);\n        } else {\n          $element.append($clipNode);\n        }\n      }\n\n      if ($rootNode.height() > options.maxHeight) {\n        if (child.nodeType === 3) { // text node\n          truncated = truncateTextContent($child, $rootNode, $clipNode, options);\n        } else {\n          truncated = truncateNestedNode($child, $rootNode, $clipNode, options);\n        }\n      }\n\n      if (!truncated && $clipNode.length) {\n        $clipNode.remove();\n      }\n\n    }\n\n    return truncated;\n  }\n\n  /* Recursively truncates a nested node.\n   *\n   * $element  - The jQuery nested node to truncate.\n   * $rootNode - The jQuery root node to measure the truncated height.\n   * $clipNode - The jQuery node to insert right after the truncation point.\n   * options   - An object containing:\n   *             ellipsis  - The ellipsis string to append at the end of the truncation.\n   *             maxHeight - The maximum height for the root node (in px).\n   *             position  - The position of the truncation (\"start\", \"middle\", \"end\").\n   *\n   * Returns true if truncation happened, false otherwise.\n   */\n  function truncateNestedNode($element, $rootNode, $clipNode, options) { // jshint ignore:line\n    if (options.position === \"end\") {\n      return truncateNestedNodeEnd($element, $rootNode, $clipNode, options);\n    }\n    else if (options.position === \"start\") {\n      return truncateNestedNodeStart($element, $rootNode, $clipNode, options);\n    }\n    else {\n      // TODO: Truncate middle for nested = HARDCORE\n      return truncateNestedNodeEnd($element, $rootNode, $clipNode, options);\n    }\n  }\n\n  /* Public: Creates an instance of Truncate.\n   *\n   * element - A DOM element to be truncated.\n   * options - An Object literal containing setup options.\n   *\n   * Examples:\n   *\n   *   var element = document.createElement('span');\n   *   element.innerHTML = 'This is<br>odd.';\n   *   var truncated = new Truncate(element, {\n   *     lines: 1,\n   *     lineHeight: 16,\n   *     ellipsis: '… ',\n   *     showMore: '<a class=\"show-more\">Show More</a>',\n   *     showLess: '<a class=\"show-less\">Show Less</a>',\n   *     position: \"start\"\n   *   });\n   *\n   *   // Update HTML\n   *   truncated.update('This is not very odd.');\n   *\n   *   // Undo truncation\n   *   truncated.expand();\n   *\n   *   // Redo truncation\n   *   truncated.collapse();\n   */\n  function Truncate(element, options) {\n    this.element = element;\n    this.$element = $(element);\n\n    this._name = 'truncate';\n    this._defaults = {\n      lines: 1,\n      ellipsis: '…',\n      showMore: '',\n      showLess: '',\n      position: 'end',\n      lineHeight: 'auto'\n    };\n\n    this.options = $.extend({}, this._defaults, options);\n\n    if (this.options.lineHeight === 'auto') {\n      var lineHeightCss = this.$element.css('line-height'),\n        lineHeight = 18; // for Normal we return the default value: 18px\n\n      if (lineHeightCss !== \"normal\") {\n        lineHeight = parseInt(lineHeightCss, 10);\n      }\n\n      this.options.lineHeight = lineHeight;\n    }\n\n    if (this.options.maxHeight === undefined) {\n      this.options.maxHeight = parseInt(this.options.lines, 10) * parseInt(this.options.lineHeight, 10);\n    }\n\n    if (this.options.position !== 'start' && this.options.position !== 'middle' && this.options.position !== 'end') {\n      this.options.position = 'end';\n    }\n\n    this.$clipNode = $($.parseHTML(this.options.showMore), this.$element);\n\n    this.original = this.cached = element.innerHTML;\n\n    this.isTruncated = false; // True if the original content overflows the container.\n    this.isCollapsed = true;  // True if the container is currently collapsed.\n\n    this.update();\n  }\n\n  Truncate.prototype = {\n\n    /* Public: Updates the inner HTML of the element and re-truncates. Will not\n     * perform an updade if the container is currently expanded, instead it\n     * will wait until the next time .collapse() is called.\n     *\n     * html - The new HTML.\n     *\n     * Returns nothing.\n     */\n    update: function (html) {\n      var wasExpanded = !this.isCollapsed;\n\n      // Update HTML if provided, otherwise use the current html and restore\n      // the truncated content to the original if it's currently present.\n      if (typeof html !== 'undefined') {\n        this.original = this.element.innerHTML = html;\n      } else if (this.isCollapsed && this.element.innerHTML === this.cached) {\n        this.element.innerHTML = this.original;\n      }\n\n      // Wrap the contents in order to ignore container's margin/padding.\n      var $wrap = this.$element.wrapInner('<div/>').children();\n      $wrap.css({\n        border: 'none',\n        margin: 0,\n        padding: 0,\n        width: 'auto',\n        height: 'auto',\n        'word-wrap': 'break-word'\n      });\n\n      this.isTruncated = false;\n      // Check if already meets height requirement\n      if ($wrap.height() > this.options.maxHeight) {\n        this.isTruncated = truncateNestedNode($wrap, $wrap, this.$clipNode, this.options);\n\n        if(this.isExplicitlyCollapsed) {\n          this.isCollapsed = true;\n          wasExpanded = false;\n        }\n      } else {\n        this.isCollapsed = false;\n      }\n\n      // Restore the wrapped contents\n      $wrap.replaceWith($wrap.contents());\n\n      // Cache the truncated content\n      this.cached = this.element.innerHTML;\n\n      // If the container was expanded when .update() was called then restore\n      // it to it's previous state.\n      if (wasExpanded) {\n        this.element.innerHTML = this.original;\n      }\n    },\n\n    /* Public: Expands the element to show content in full.\n     *\n     * Returns nothing.\n     */\n    expand: function () {\n      var includeShowLess = true;\n\n      if(this.isExplicitlyCollapsed) {\n        this.isExplicitlyCollapsed = false;\n        includeShowLess = false;\n      }\n\n      if (!this.isCollapsed) {\n        return;\n      }\n\n      this.isCollapsed = false;\n\n      this.element.innerHTML = this.isTruncated ? this.original + (includeShowLess ? this.options.showLess : \"\") : this.original;\n    },\n\n    /* Public: Collapses the element to the truncated state.\n     * Uses the cached HTML from .update() by default.\n     *\n     * retruncate - True to retruncate original HTML, otherwise use cached HTML.\n     *\n     * Returns nothing.\n     */\n    collapse: function (retruncate) {\n      this.isExplicitlyCollapsed = true;\n      \n      if (this.isCollapsed) {\n        return;\n      }\n\n      this.isCollapsed = true;\n\n      retruncate = retruncate || false;\n      if (retruncate) {\n        this.update();\n      } else {\n        this.element.innerHTML = this.cached;\n      }\n    }\n  };\n\n  // Lightweight plugin wrapper preventing multiple instantiations\n  $.fn.truncate = function (options) {\n    var args = $.makeArray(arguments).slice(1);\n    return this.each(function () {\n      var truncate = $.data(this, 'jquery-truncate');\n      if (!truncate) {\n        $.data(this, 'jquery-truncate', new Truncate(this, options));\n      } else if (typeof truncate[options] === 'function') {\n        truncate[options].apply(truncate, args);\n      }\n    });\n  };\n\n  module.Truncate = Truncate;\n\n})(this, jQuery);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/truncate.js/truncate.js\n ** module id = 217\n ** module chunks = 7\n **/"],"sourceRoot":""}